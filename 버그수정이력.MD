버그수정이력

1. buffer_LS_Width 0 으로 인해 Exception 발생

문제 분석 결과
buffer_LS_Width가 0이 되는 원인을 찾았습니다. 문제는 다음과 같은 시나리오에서 발생합니다:
원인 분석
초기화 문제 (gf.cs:1220, gf.cs:1228)
LS_Width = 0으로 초기화됨
Buffer_LS_Width = 0으로 초기화됨
SizeLaunchScreen() 함수 호출 시 (gf.cs:7897-7958)
gf.cs:7904에서 GetScreenName()을 호출하여 LS_Width를 설정하려고 시도
그러나 selectScreen이 null인 경우 (gf.cs:8285-8312)에는 w (LS_Width) 파라미터가 업데이트되지 않음
GetScreenName() 함수의 문제점 (gf.cs:8262-8346)

if (selectScreen != null)
{
// w, h, t, l 값을 설정
}
// else 구문이 없어서 selectScreen이 null이면 w 값이 설정되지 않음!
selectScreen이 null일 때를 처리하는 else 블록이 없음
예외가 발생하면 catch 블록에서 selectScreen.Bounds.Size를 접근하려고 하는데, selectScreen이 여전히 null이면 또다시 예외 발생
결과적으로
LS_Width가 0으로 남음
gf.cs:7929-7938의 조건문에서:
LS_Height >= 768이면 Buffer_LS_Width = LS_Width (즉, 0)
LS_Height < 768이면 Buffer_LS_Width = (int)((float)LS_Width * num) (즉, 0)
FormatText에서 문제 발생 (gf.cs:7246)

int buffer_LS_Width = Buffer_LS_Width; // 0이 할당됨
gf.cs:7318-7319에서 0으로 나누기 시도 가능
추가로 발견된 보완 로직
gf.cs:13307-13344의 SetDefaultBackScreen() 함수에 임시 보완 코드가 있지만, 이것은 FormatText()에서는 적용되지 않습니다.
해결 방법
GetScreenName() 함수 수정: selectScreen == null일 때 기본값 설정
SizeLaunchScreen() 함수 수정: LS_Width가 0이면 기본값 설정
FormatText() 함수 시작 부분에 보호 코드 추가: Buffer_LS_Width가 0이면 기본값 설정


------------------------------------------------------------------------------------------------------------------

FrmMain에서 WorshipListItems 선택 이동시 delay 발생 PPT 미리보기 다시 그려 주는 부분에서 Delay 발생 되는지 전반적으로 확인 해줘

FrmMain.cs에서 WorshipListItems 선택 이동 시 발생하는 delay를 확인하기 위해 PPT 미리보기 관련 코드를 전반적으로 분석하겠습니다.

* [ ]  FrmMain.cs에서 WorshipListItems 선택 이벤트 핸들러 찾기
* [ ]  PPT 미리보기 그리기 관련 메서드 식별
* [ ]  동기/비동기 호출 패턴 분석
* [ ]  Delay 발생 원인 파악 및 보고

**291 lines of output**

**2 lines of output**

이제 WorshipListIndexChanged 메서드를 찾아보겠습니다. 이것이 선택 변경 시 호출되는 핵심 메서드입니다.

**20 lines of output**

이제 전체 WorshipListIndexChanged 메서드를 읽어보겠습니다.

계속해서 LoadItem 메서드를 읽어보겠습니다.

이제 BuildAllPowerpointScreenDumps와 ShowPreviewPPThumbs 메서드를 더 자세히 살펴보겠습니다.

**12 lines of output**

* [ ]  FrmMain.cs에서 WorshipListItems 선택 이벤트 핸들러 찾기
* [ ]  PPT 미리보기 그리기 관련 메서드 식별
* [ ]  동기/비동기 호출 패턴 분석
* [ ]  Delay 발생 원인 파악 및 보고

이제 LoadThumbPreviewImages 메서드를 찾아보겠습니다.

**7 lines of output**

이제 BuildNewImageThumbs 메서드를 찾아보겠습니다. 이것이 ImageCanvas 클래스의 메서드일 것입니다.

**Found 1 file**

**4 lines of output**

이제 전체 호출 흐름을 파악했으니, 동기/비동기 패턴을 분석하고 BuildScreenPreDumps 메서드를 확인하겠습니다.

**4 lines of output**

* [ ]  FrmMain.cs에서 WorshipListItems 선택 이벤트 핸들러 찾기
* [ ]  PPT 미리보기 그리기 관련 메서드 식별
* [ ]  동기/비동기 호출 패턴 분석
* [ ]  Delay 발생 원인 파악 및 보고

**7 lines of output**

이제 IsBuildedFileCheck 메서드를 확인해보겠습니다.

**15 lines of output**

* [ ]  FrmMain.cs에서 WorshipListItems 선택 이벤트 핸들러 찾기
* [ ]  PPT 미리보기 그리기 관련 메서드 식별
* [ ]  동기/비동기 호출 패턴 분석
* [ ]  Delay 발생 원인 파악 및 보고

완벽합니다! 이제 모든 분석이 완료되었습니다. 보고서를 작성하겠습니다.

* [ ]  FrmMain.cs에서 WorshipListItems 선택 이벤트 핸들러 찾기
* [ ]  PPT 미리보기 그리기 관련 메서드 식별
* [ ]  동기/비동기 호출 패턴 분석
* [ ]  Delay 발생 원인 파악 및 보고

## WorshipListItems 선택 이동 시 Delay 발생 원인 분석 완료

FrmMain.cs에서 WorshipListItems 선택 이동 시 발생하는 delay를 전반적으로 분석한 결과를 보고드립니다.

### 📋 호출 흐름 분석

**1. 선택 변경 이벤트 흐름:**

```
WorshipListItems.Items[n].Selected = true
    ↓
WorshipListIndexChanged()
    ↓
WorshipListIndexChanged(int StartingSlide, bool GetFirstItem)
    ↓
LoadItem()
    ↓
BuildAllPowerpointScreenDumps()
    ↓
gf.PreviewPPT.BuildScreenPreDumps() [동기 호출]
    ↓
ShowPreviewPPThumbs()
    ↓
LoadThumbPreviewImages()
    ↓
ImageCanvas.BuildNewImageThumbs()
    ↓
ImageCanvas.Calc_Image() + Invalidate()
```

### ⚠️ Delay 발생 주요 원인

#### **1. PowerPoint 파일 처리 (가장 큰 병목)**

**위치:** [OfficeLib/PowerPoint.cs:757-884](vscode-webview://1nilekc6ceiuurckheof892q0btojisvgae8v6utba7c9mld6g2e/OfficeLib/PowerPoint.cs#L757-L884)

```csharp
public bool BuildScreenPreDumps(...)
{
    // ❌ 동기 방식으로 PPT 파일 오픈
    presentation = prePowerPointApp.Presentations.Open(FilePath, ...);
  
    if (!IsBuildedFileCheck(presentation, FilePath, FilePrefix, ref TotalSlides))
    {
        // ❌ 모든 슬라이드를 순차적으로 Export (매우 느림)
        for (int i = 1; i <= TotalSlides; i++)
        {
            strPreFileName = FilePrefix + Convert.ToString(i) + ".jpg";
            presentation.Slides[i].Export(strPreFileName, "JPG", 640, 480);
            File.Copy(strPreFileName, strOutFileName, true);
        }
    }
}
```

**문제점:**

* PowerPoint Interop 호출이 **완전히 동기 방식**으로 실행됨
* 슬라이드가 많을 경우 Export가 매우 오래 걸림 (슬라이드당 수백ms\~수초)
* UI 스레드가 블로킹되어 사용자 인터페이스가 멈춤

#### **2. 캐시 체크 로직의 한계**

**위치:** [FrmMain.cs:4955-4960](vscode-webview://1nilekc6ceiuurckheof892q0btojisvgae8v6utba7c9mld6g2e/FrmMain.cs#L4955-L4960)

```csharp
if (!gf.PreviewPPT.IsBuildedFileCheck(gf.PreviewItem.Path, filePrefix, ref gf.PreviewItem.TotalSlides) 
    || preSelectedItemNum != num)
{
    // 캐시가 없거나 다른 항목을 선택하면 항상 LoadItem 호출
    LoadItem(ref gf.PreviewItem, text, ...);
}
```

**문제점:**

* `IsBuildedFileCheck`에서 JPG 파일 존재 여부와 타임스탬프만 확인
* 같은 파일을 다시 선택해도 `preSelectedItemNum != num` 조건 때문에 재로딩
* 파일 시스템 I/O가 매번 발생

#### **3. 이미지 썸네일 처리**

**위치:** [FrmMain.cs:3631-3672](vscode-webview://1nilekc6ceiuurckheof892q0btojisvgae8v6utba7c9mld6g2e/FrmMain.cs#L3631-L3672), [ImageCanvas.cs:496-583](vscode-webview://1nilekc6ceiuurckheof892q0btojisvgae8v6utba7c9mld6g2e/ImageCanvas.cs#L496-L583)

```csharp
private void LoadThumbPreviewImages(...)
{
    if (LoadThumbPreviewlockkey == 0)
    {
        // ❌ 첫 로드 시 모든 썸네일을 순차적으로 처리
        for (int i = 0; i < TotalImagesCount; i++)
        {
            InCanvas[i].BuildNewImageThumbs(...);
        }
    }
}

public bool Calc_Image()
{
    // ❌ 동기적으로 이미지 로드 및 고품질 렌더링
    using (Image image = Image.FromFile(FileName))
    {
        // 해상도 2배 증가 (520-521줄)
        StoredImageWidth *= 2;
        StoredImageHeight *= 2;
    
        // 고품질 그래픽 설정으로 느림
        graphics.InterpolationMode = InterpolationMode.HighQualityBicubic;
    }
}
```

**문제점:**

* 모든 썸네일 이미지를 **동기적으로** 파일에서 로드
* 고품질 이미지 리사이징 (해상도 2배 증가)으로 CPU 부하
* 슬라이드가 많을수록 초기 로딩 시간이 선형적으로 증가

#### **4. 불필요한 중복 처리**

**위치:** [FrmMain.cs:5080-5090](vscode-webview://1nilekc6ceiuurckheof892q0btojisvgae8v6utba7c9mld6g2e/FrmMain.cs#L5080-L5090)

```csharp
BuildAllPowerpointScreenDumps(ref InItem);
InItem.CurSlide = StartingSlide;
// ...
if (InItem.OutputStyleScreen)
{
    ShowOutputPPThumbs(InItem.CurSlide);
}
else
{
    ShowPreviewPPThumbs(InItem.CurSlide);  // ❌ 다시 모든 썸네일 재구성
}
```

### 🎯 최적화 권장사항

**1. 비동기 처리 도입 (가장 중요)**

```csharp
// PowerPoint Export를 백그라운드 스레드로 이동
private async Task<bool> BuildScreenPreDumpsAsync(...)
{
    await Task.Run(() => {
        // PowerPoint Export 작업
    });
}

// UI 업데이트는 메인 스레드에서
await BuildScreenPreDumpsAsync(...);
ShowPreviewPPThumbs(InItem.CurSlide);
```

**2. 썸네일 지연 로딩**

* 현재 선택된 슬라이드 주변만 먼저 로드
* 나머지는 스크롤 시 동적으로 로드
* `LoadThumbPreviewlockkey` 로직 개선 (이미 부분적으로 구현되어 있음)

**3. 더 효율적인 캐싱**

```csharp
// 메모리 캐시에 이미지 보관
Dictionary<string, Image> thumbnailCache = new Dictionary<string, Image>();

// 파일 해시로 변경 여부 확인
if (IsCacheValid(fileHash)) {
    return cachedThumbnails;
}
```

**4. 이미지 로딩 최적화**

* 해상도 2배 증가 옵션을 선택적으로 적용
* `InterpolationMode`를 `HighQualityBicubic` 대신 `Bilinear` 사용 (프리뷰용)
* 이미지 풀(Pool) 사용으로 GC 부하 감소

### 📊 성능 영향도 요약


| 구간                             | 예상 지연 시간 | 영향도        |
| -------------------------------- | -------------- | ------------- |
| PowerPoint Export (캐시 없을 때) | 수초\~수십초   | **매우 높음** |
| 썸네일 이미지 로딩 (첫 로드)     | 수백ms\~수초   | **높음**      |
| IsBuildedFileCheck               | 수십ms         | 중간          |
| UI 렌더링 (Invalidate)           | 수십ms         | 낮음          |

**결론:** Delay의 가장 큰 원인은 **PowerPoint Interop의 동기 방식 Export**와 **모든 썸네일의 동기 로딩**입니다. 비동기 처리와 지연 로딩을 도입하면 체감 성능을 크게 개선할 수 있습니다.

작업을 진행 해줘
